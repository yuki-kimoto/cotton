# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Eg::Node {
  allow Eg;
  
  use Hash;
  use List;
  use StringBuffer;
  use Eg::Text;
  
  enum {
    TYPE_ELEMENT_NODE = 1,
    TYPE_ATTRIBUTE_NODE = 2,
    TYPE_TEXT_NODE = 3,
    TYPE_CDATA_SECTION_NODE = 4,
    TYPE_PROCESSING_INSTRUCTION_NODE = 7,
    TYPE_COMMENT_NODE = 8,
    TYPE_DOCUMENT_NODE = 9,
    TYPE_DOCUMENT_TYPE_NODE = 10,
    TYPE_DOCUMENT_FRAGMENT_NODE = 11,
  }
  
  # Fields
  has type : ro int;
  
  has child_nodes_list : ro List of Eg::Node;
  
  has attributes_h : ro Hash of string;
  
  has styles_h : ro Hash of string;
  
  has tag_name : ro string;
  
  has value_buffer : ro StringBuffer;
  
  has parent : ro Eg::Node;
  
  # Class Methods
  static method new : Eg::Node ($type : int, $child_nodes : Eg::Node[] = undef) {
    
    my $self = new Eg::Node;
    
    $self->init($type, $child_nodes);
    
    return $self;
  }
  
  private static method copy_object_with_proto : object[] ($array : object[], $proto : object[], $cloner : Cloner = undef, $offset : int = 0, $length : int = -1) {
    
    unless ($array) {
      die "\$array must be defined.";
    }
    
    unless ($offset >= 0) {
      die "\$offset must be greater than or equal to 0.";
    }
    
    my $array_length = @$array;
    if ($length < 0) {
      $length = $array_length - $offset;
    }
    
    unless ($offset + $length <= $array_length) {
      die "\$offset + \$length must be less than or equal to the length of \$array.";
    }
    
    unless ($proto) {
      $proto = $array;
    }
    
    my $new_array = Array->new_proto($proto, $length);
    
    if ($cloner) {
      for (my $i = 0; $i < $length; $i++) {
        $new_array->[$i] = $cloner->($array->[$offset + $i]);
      }
    }
    else {
      Array->memcpy_object_address($new_array, 0, $array, $offset, $length);
    }
    
    return $new_array;
  }
  
  private static method copy_object_address_with_proto : object[] ($array : object[], $proto : object[], $offset : int = 0, $length : int = -1) {
    return &copy_object_with_proto($array, $proto, undef, $offset, $length);
  }
  
  # Instance Methods
  protected method init : void ($type : int, $child_nodes : Eg::Node[] = undef) {
    
    $self->{type} = $type;
    
    if ($child_nodes) {
      unless ($child_nodes is_type Eg::Node[]) {
        $child_nodes = (Eg::Node[])&copy_object_address_with_proto($child_nodes, new Eg::Node[0]);
      }
    }
    else {
      $child_nodes = new Eg::Node[0];
    }
    
    $self->{child_nodes_list} = List->new($child_nodes);
    
    if ($child_nodes) {
      for my $node (@$child_nodes) {
        $node->{parent} = $self;
        weaken $node->{parent};
      }
    }
    
  }
  
  method attr : string ($name : string) {
    
    my $attributes_h = $self->{attributes_h};
    
    unless ($self->{attributes_h}) {
      return undef;
    }
    
    my $attr = (string)$attributes_h->get($name);
    
    return $attr;
  }
  
  method set_attr : void ($name : string, $value : string) {
    
    my $attributes_h = $self->{attributes_h};
    
    unless ($attributes_h) {
      $attributes_h = $self->{attributes_h} = Hash->new;
    }
    
    $attributes_h->set_string($name, $value);
  }
  
  method exists_attr : int ($name : string) {
    
    my $attributes_h = $self->{attributes_h};
    
    my $exists = 0;
    if ($attributes_h) {
      $exists = $attributes_h->exists($name);
    }
    
    return $exists;
  }
  
  method remove_attr : void ($name : string) {
    
    my $attributes_h = $self->{attributes_h};
    
    my $deleted_attr = (string)undef;
    
    if ($self->{attributes_h}) {
      $attributes_h->delete($name);
    }
  }
  
  method attribute_pairs : string[] () {
    
    my $attributes_h = $self->{attributes_h};
    
    my $attribute_pairs = (string[])undef;
    
    if ($attributes_h) {
      my $names = $attributes_h->keys;
      
      Sort->sort_string_asc($names);
      
      my $attribute_pairs_list = StringList->new;
      for my $name (@$names) {
        my $value = $attributes_h->get_string($name);
        
        $attribute_pairs_list->push($name);
        $attribute_pairs_list->push($value);
      }
      
      $attribute_pairs = $attribute_pairs_list->to_array;
    }
    else {
      $attribute_pairs = new string[0];
    }
    
    return $attribute_pairs;
  }
  
  method css : string ($name : string) {
    
    my $styles_h = $self->{styles_h};
    
    unless ($self->{styles_h}) {
      return undef;
    }
    
    my $css = (string)$styles_h->get($name);
    
    return $css;
  }
  
  method set_css : void ($name : string, $value : string) {
    
    my $styles_h = $self->{styles_h};
    
    unless ($styles_h) {
      $styles_h = $self->{styles_h} = Hash->new;
    }
    
    $styles_h->set_string($name, $value);
  }
  
  method exists_css : int ($name : string) {
    
    my $styles_h = $self->{styles_h};
    
    my $exists = 0;
    if ($styles_h) {
      $exists = $styles_h->exists($name);
    }
    
    return $exists;
  }
  
  method remove_css : void ($name : string) {
    
    my $styles_h = $self->{styles_h};
    
    my $deleted_css = (string)undef;
    
    if ($self->{styles_h}) {
      $styles_h->delete($name);
    }
  }
  
  method style_pairs : string[] () {
    
    my $styles_h = $self->{styles_h};
    
    my $style_pairs = (string[])undef;
    
    if ($styles_h) {
      my $names = $styles_h->keys;
      
      Sort->sort_string_asc($names);
      
      my $style_pairs_list = StringList->new;
      for my $name (@$names) {
        my $value = $styles_h->get_string($name);
        
        $style_pairs_list->push($name);
        $style_pairs_list->push($value);
      }
      
      $style_pairs = $style_pairs_list->to_array;
    }
    else {
      $style_pairs = new string[0];
    }
    
    return $style_pairs;
  }
  
  method text : string () {
    my $child_nodes = $self->{child_nodes_list};
    
    my $child_nodes_length = $child_nodes->length;
    
    my $text = (string)undef;
    
    if ($child_nodes_length > 0) {
      my $first_child = (Eg::Node)$child_nodes->get(0);
      
      if ($first_child->type == &TYPE_TEXT_NODE) {
        $text = $first_child->{value_buffer}->to_string;
      }
      else {
        die "The first child is not a text node.";
      }
    }
    else {
      return "";
    }
    
    return $text;
  }
  
  method set_text : string ($text : string) {
    my $child_nodes = $self->{child_nodes_list};
    
    my $child_nodes_length = $child_nodes->length;
    
    if ($child_nodes_length > 0) {
      my $first_child = (Eg::Node)$child_nodes->get(0);
      
      if ($first_child->type == &TYPE_TEXT_NODE) {
        $first_child->{value_buffer}->set($text);
      }
      else {
        die "The first child is not a text node.";
      }
    }
    else {
      $self->{child_nodes_list} = List->new([Eg::Text->new($text)]);
    }
    
  }
  
  method children : Eg::Node[] () {
    my $child_nodes_list = $self->{child_nodes_list};
    
    my $child_nodes = (Eg::Node[])undef;
    if ($child_nodes_list) {
      $child_nodes = (Eg::Node[])$child_nodes_list->to_array;
    }
    else {
      $child_nodes = new Eg::Node[0];
    }
    
    return $child_nodes;
  }
  
  method append : void ($node : Eg::Node) {
    
    unless ($node) {
      die "\$node must be defined.";
    }
    
    my $child_nodes_list = $self->{child_nodes_list};
    
    $child_nodes_list->push($node);
  }
  
  method prepend : void ($node : Eg::Node) {
    
    unless ($node) {
      die "\$node must be defined.";
    }
    
    my $child_nodes_list = $self->{child_nodes_list};
    
    $child_nodes_list->unshift($node);
  }
  
  method after : void ($node : Eg::Node) {
    
    unless ($node) {
      die "\$node must be defined.";
    }
    
    my $parent = $self->{parent};
    
    unless ($node) {
      die "The parent of \$node must be defined.";
    }
    
    my $sibling_nodes_list = $parent->{child_nodes_list};
    
    my $sibling_nodes_length = $sibling_nodes_list->length;
    
    for (my $i = 0; $i < $sibling_nodes_length; $i++) {
      my $sibling = $sibling_nodes_list->get($i);
      
      if ($sibling == $self) {
        $sibling_nodes_list->insert($i + 1, $node);
        last;
      }
    }
  }
  
  method before : void ($node : Eg::Node) {
    
    unless ($node) {
      die "\$node must be defined.";
    }
    
    my $parent = $self->{parent};
    
    unless ($node) {
      die "The parent of \$node must be defined.";
    }
    
    my $sibling_nodes_list = $parent->{child_nodes_list};
    
    my $sibling_nodes_length = $sibling_nodes_list->length;
    
    for (my $i = 0; $i < $sibling_nodes_length; $i++) {
      my $sibling = $sibling_nodes_list->get($i);
      
      if ($sibling == $self) {
        $sibling_nodes_list->insert($i, $node);
        last;
      }
    }
  }
  
}
