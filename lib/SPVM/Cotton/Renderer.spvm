class Cotton::Renderer {
  use Cotton::App;
  use Cotton::Runtime;
  
  use Cotton as Ct;
  
  use Fn;
  use Sort;
  
  static method new : Cotton::Renderer () {
    return new Cotton::Renderer;
  }
  
  method paint_nodes : void($runtime : Cotton::Runtime, $paint_info : Cotton::PaintInfo) {
    my $app = $runtime->app;
    
    my $page = $app->current_page;
    
    my $viewport_width = $runtime->api->get_viewport_width();
    my $viewport_height = $runtime->api->get_viewport_height();
    
    {
      my $body = $page->body;
      
      $body->{draw_left} = 0;
      $body->{draw_top} = 0;
      $body->{draw_width} = $viewport_width;
      
      my $nodes = $self->convert_dom_to_excution_order($app, $body);
      for (my $i = 0; $i < @$nodes; $i++) {
        my $node = $nodes->[$i];
        $node->{draw_left} = 0;
        $node->{draw_top} = 0;
        $node->{draw_width} = $viewport_width;
        
        warn $node->{text}->to_string;
        
        my $draw_height = $runtime->api->calc_text_height($paint_info, $node->{text}->to_string, $viewport_width, undef);
        
        $node->{draw_height} = $draw_height;
        
        $runtime->api->paint_node($paint_info, $node);
      }
    }

    {
      my $node_list = List->new([]);
      {
        my $node = Cotton::Node->new;
        
        $node->{draw_left} = 300;
        $node->{draw_top} = 500;
        $node->{draw_width} = 400;
        $node->{draw_height} = 400;
        $node_list->push($node);
        $node->set_background_color(Ct->rgb(0xFF, 0x00, 0x00));
      }
      {
        my $node = Cotton::Node->new;
        $node->{draw_left} = 400;
        $node->{draw_top} = 600;
        $node->{draw_width} = 500;
        $node->{draw_height} = 500;
        $node_list->push($node);
        $node->set_background_color(Ct->rgb(0xFF, 0x00, 0x00));
      }
      
      # Drow node
      my $node_list_length = $node_list->length;
      for (my $i = 0; $i < $node_list_length; $i++) {
        my $node = (Cotton::Node)$node_list->get($i);
        warn "AAAAAAA";
        $runtime->api->paint_node($paint_info, $node);
      }
    }
  }

  method convert_dom_to_excution_order : Cotton::Node[] ($app : Cotton::App, $root_node : Cotton::Node) {
    
    my $execution_order_before_z_index_sort = 0;
    
    # convert_dom_to_excution_order
    my $node_list = List->new(new Cotton::Node[0]);
    my $cur_node = $root_node;
    my $finish = 0;
    while ($cur_node) {
      # [START]Preorder traversal position
      $cur_node->{execution_order_before_z_index_sort} = $execution_order_before_z_index_sort;
      $execution_order_before_z_index_sort++;
      $node_list->push($cur_node);
      
      # [END]Preorder traversal position
      
      if ($cur_node->first) {
        $cur_node = $cur_node->first;
      }
      else {
        while (1) {
          # [START]Postorder traversal position
          # [END]Postorder traversal position
          
          if ($cur_node == $root_node) {

            # Finish
            $finish = 1;
            
            last;
          }
          
          # Next sibling
          if ($cur_node->moresib) {
            $cur_node = $cur_node->sibparent;
            last;
          }
          # Next is parent
          else {
            $cur_node = $cur_node->sibparent;
          }
        }
        if ($finish) {
          last;
        }
      }
    }

    my $nodes = (Cotton::Node[])$node_list->to_array;
    
    Sort->sort_object($nodes, method : int ($object1 : object, $object2 : object) {
      my $node1 = (Cotton::Node)$object1;
      my $node2 = (Cotton::Node)$object2;
      
      if ($node1->z_index > $node2->z_index) {
        return 1;
      }
      elsif ($node1->z_index < $node2->z_index) {
        return -1;
      }
      else {
        if ($node1->execution_order_before_z_index_sort > $node1->execution_order_before_z_index_sort) {
          return 1;
        }
        elsif ($node1->execution_order_before_z_index_sort < $node1->execution_order_before_z_index_sort) {
          return -1;
        }
        else {
          return 0;
        }
      }
    });
    
    return $nodes;
  }

}
